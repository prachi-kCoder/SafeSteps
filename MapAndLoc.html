<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <title>Place Autocomplete with TomTom API</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.css">
    <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.19.0/maps/maps-web.min.js"></script>
    <script src="https://api.tomtom.com/search/2/search.min.js"></script>
    <link rel="stylesheet" href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.19.0/maps/maps.css" />
    <style>
      #map { height: 100%; }
      html, body { height: 100%; margin: 0; padding: 0; }
      .controls { margin-top: 10px; border: 1px solid transparent; border-radius: 2px 0 0 2px; height: 32px; outline: none; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3); }
      #origin-input, #destination-input { background-color: #fff; font-family: Roboto; font-size: 15px; font-weight: 300; margin-left: 12px; padding: 0 11px 0 13px; width: 200px; }
      #origin-input:focus, #destination-input:focus { border-color: #4d90fe; }
      #mode-selector { color: #fff; background-color: #4d90fe; margin-left: 12px; padding: 5px 11px 0px 11px; }
      #mode-selector label { font-family: Roboto; font-size: 13px; font-weight: 300; }
    </style>
  </head>
  <body>
    <div class="ui main container segment">
      <h1 style="font-size: 75px; font-family: georgia">ETIHAAD</h1>
      <h2 style="text-align: right; font-family: georgia">Because you must look before you leave!</h2>
    </div>

    <!-- Input fields for origin and destination -->
    <input id="origin-input" class="controls" type="text" placeholder="Enter an origin location">
    <input id="destination-input" class="controls" type="text" placeholder="Enter a destination location">
    <div id="mode-selector" class="controls">
      <input type="radio" name="type" id="changemode-walking" checked="checked">
      <label for="changemode-walking">Walking</label>
      <input type="radio" name="type" id="changemode-driving">
      <label for="changemode-driving">Driving</label>
    </div>
    <button id="getRouteButton" class="ui button" style="margin-top: 20px;">Get Route</button>
    <div id="map"></div>

    <script>
      const API_KEY = '3YzQxwAFHF8yAMWxHfKrjbNN1U3WHarx';
      let map = tt.map({
        key: API_KEY,
        container: 'map',
        center: [77.2042, 28.5299], // Default center coordinates (adjust as needed)
        zoom: 7,
      });

      const originSearchBox = new tt.plugins.SearchBox(tt.services.fuzzySearch, {
        key: API_KEY,
        searchOptions: { typeahead: true },
        placeholder: 'Enter origin',
      });

      const destinationSearchBox = new tt.plugins.SearchBox(tt.services.fuzzySearch, {
        key: API_KEY,
        searchOptions: { typeahead: true },
        placeholder: 'Enter destination',
      });

      document.getElementById('origin-input').appendChild(originSearchBox.getSearchBoxHTML());
      document.getElementById('destination-input').appendChild(destinationSearchBox.getSearchBoxHTML());

      let routeLayer;
      let dangerData = []; // This will hold the loaded data from data.json

      // Function to load data.json
      function loadData() {
        fetch('./data/data.json')  // Adjust the path to your actual data location
          .then(response => response.json())
          .then(data => {
            dangerData = data;
          })
          .catch(error => console.error('Error loading danger data:', error));
      }

      // Function to calculate danger index
      function getDangerIndexAtPoint(lat, lon) {
        // Find the closest point in the data array
        let closestPoint = null;
        let minDistance = Infinity;

        dangerData.forEach(item => {
          const distance = calculateDistance(lat, lon, item.lati, item.longi);
          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = item;
          }
        });

        // Return the danger index based on the closest point
        if (closestPoint) {
          return closestPoint.properties.mag; // Assuming 'mag' represents the danger index
        } else {
          return 0; // Default value if no data found
        }
      }

      // Haversine formula to calculate the distance between two lat-lon points in kilometers
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the Earth in km
        const dLat = degreesToRadians(lat2 - lat1);
        const dLon = degreesToRadians(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(degreesToRadians(lat1)) * Math.cos(degreesToRadians(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // Distance in km
      }

      // Convert degrees to radians
      function degreesToRadians(degrees) {
        return degrees * (Math.PI / 180);
      }

      // Load the data when the page loads
      window.onload = loadData;

      // Function to adjust the route for safety
      function adjustRouteForSafety(routeGeoJson) {
        let adjustedRoute = routeGeoJson.features[0].geometry.coordinates.map((point) => {
          let dangerIndex = getDangerIndexAtPoint(point[1], point[0]);
          console.log(`Danger index at ${point[1]}, ${point[0]}: ${dangerIndex}`);
          if (dangerIndex > 50) {
            console.log("High danger area detected, rerouting...");
            return reroutePoint(point);
          }
          return point;
        });
        return adjustedRoute;
      }

      // Placeholder function for rerouting logic
      function reroutePoint(point) {
        console.log("Rerouting around high danger area...");
        return point; // Placeholder (can be extended to implement actual rerouting logic)
      }

      // Function to calculate route and display it
      function calculateRoute(origin, destination) {
        if (routeLayer) map.removeLayer(routeLayer);

        tt.services.calculateRoute({
          key: API_KEY,
          locations: `${origin.lon},${origin.lat}:${destination.lon},${destination.lat}`,
          travelMode: 'car',
        }).then((response) => {
          const geojson = response.toGeoJson();
          const adjustedRoute = adjustRouteForSafety(geojson);

          routeLayer = new tt.Layer({
            id: 'route-layer',
            type: 'line',
            source: { type: 'geojson', data: { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: { type: 'LineString', coordinates: adjustedRoute } }] } },
          });
          map.addLayer(routeLayer);
        });
      }

      // Event listener for the Get Route button
      document.getElementById('getRouteButton').addEventListener('click', () => {
        const origin = originSearchBox.getSelectedResult() ? originSearchBox.getSelectedResult().position : null;
        const destination = destinationSearchBox.getSelectedResult() ? destinationSearchBox.getSelectedResult().position : null;

        if (origin && destination) {
          console.log('Origin:', origin);
          console.log('Destination:', destination);
          calculateRoute(origin, destination);
        } else {
          alert('Please select both origin and destination.');
        }
      });

      originSearchBox.on('resultselected', (event) => {
        const origin = event.result.position;
        console.log('Origin selected:', origin);
      });

      destinationSearchBox.on('resultselected', (event) => {
        const destination = event.result.position;
        console.log('Destination selected:', destination);
      });
    </script>
  </body>
</html>
